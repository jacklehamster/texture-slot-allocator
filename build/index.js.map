{
  "version": 3,
  "sources": ["../node_modules/avl/src/utils.js", "../node_modules/avl/src/index.js", "../src/texture/TextureSlot.ts", "../src/texture/TextureUtils.ts", "../src/texture/TextureSlotAllocator.ts", "../src/image/ImagePacker.ts"],
  "sourcesContent": [
    "/**\n * Prints tree horizontally\n * @param  {Node}                       root\n * @param  {Function(node:Node):String} [printNode]\n * @return {String}\n */\nexport function print (root, printNode = (n) => n.key) {\n  var out = [];\n  row(root, '', true, (v) => out.push(v), printNode);\n  return out.join('');\n}\n\n/**\n * Prints level of the tree\n * @param  {Node}                        root\n * @param  {String}                      prefix\n * @param  {Boolean}                     isTail\n * @param  {Function(in:string):void}    out\n * @param  {Function(node:Node):String}  printNode\n */\nfunction row (root, prefix, isTail, out, printNode) {\n  if (root) {\n    out(`${ prefix }${ isTail ? '└── ' : '├── ' }${ printNode(root) }\\n`);\n    const indent = prefix + (isTail ? '    ' : '│   ');\n    if (root.left)  row(root.left,  indent, false, out, printNode);\n    if (root.right) row(root.right, indent, true,  out, printNode);\n  }\n}\n\n/**\n * Is the tree balanced (none of the subtrees differ in height by more than 1)\n * @param  {Node}    root\n * @return {Boolean}\n */\nexport function isBalanced(root) {\n  if (root === null) return true; // If node is empty then return true\n\n  // Get the height of left and right sub trees\n  var lh = height(root.left);\n  var rh = height(root.right);\n\n  if (Math.abs(lh - rh) <= 1 &&\n      isBalanced(root.left)  &&\n      isBalanced(root.right)) return true;\n\n  // If we reach here then tree is not height-balanced\n  return false;\n}\n\n/**\n * The function Compute the 'height' of a tree.\n * Height is the number of nodes along the longest path\n * from the root node down to the farthest leaf node.\n *\n * @param  {Node} node\n * @return {Number}\n */\nfunction height(node) {\n  return node ? (1 + Math.max(height(node.left), height(node.right))) : 0;\n}\n\nexport function loadRecursive (parent, keys, values, start, end) {\n  const size = end - start;\n  if (size > 0) {\n    const middle = start + Math.floor(size / 2);\n    const key    = keys[middle];\n    const data   = values[middle];\n    const node   = { key, data, parent };\n    node.left    = loadRecursive(node, keys, values, start, middle);\n    node.right   = loadRecursive(node, keys, values, middle + 1, end);\n    return node;\n  }\n  return null;\n}\n\nexport function markBalance(node) {\n  if (node === null) return 0;\n  const lh = markBalance(node.left);\n  const rh = markBalance(node.right);\n\n  node.balanceFactor = lh - rh;\n  return Math.max(lh, rh) + 1;\n}\n\nexport function sort(keys, values, left, right, compare) {\n  if (left >= right) return;\n\n  // eslint-disable-next-line no-bitwise\n  const pivot = keys[(left + right) >> 1];\n  let i = left - 1;\n  let j = right + 1;\n\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    do i++; while (compare(keys[i], pivot) < 0);\n    do j--; while (compare(keys[j], pivot) > 0);\n    if (i >= j) break;\n\n    let tmp = keys[i];\n    keys[i] = keys[j];\n    keys[j] = tmp;\n\n    tmp = values[i];\n    values[i] = values[j];\n    values[j] = tmp;\n  }\n\n  sort(keys, values,  left,     j, compare);\n  sort(keys, values, j + 1, right, compare);\n}\n",
  "import { print, isBalanced, loadRecursive, markBalance, sort } from './utils';\n\n// function createNode (parent, left, right, height, key, data) {\n//   return { parent, left, right, balanceFactor: height, key, data };\n// }\n\n/**\n * @typedef {{\n *   parent:        ?Node,\n *   left:          ?Node,\n *   right:         ?Node,\n *   balanceFactor: number,\n *   key:           Key,\n *   data:          Value\n * }} Node\n */\n\n/**\n * @typedef {*} Key\n */\n\n/**\n * @typedef {*} Value\n */\n\n/**\n * Default comparison function\n * @param {Key} a\n * @param {Key} b\n * @returns {number}\n */\nfunction DEFAULT_COMPARE (a, b) { return a > b ? 1 : a < b ? -1 : 0; }\n\n/**\n * Single left rotation\n * @param  {Node} node\n * @return {Node}\n */\nfunction rotateLeft (node) {\n  var rightNode = node.right;\n  node.right    = rightNode.left;\n\n  if (rightNode.left) rightNode.left.parent = node;\n\n  rightNode.parent = node.parent;\n  if (rightNode.parent) {\n    if (rightNode.parent.left === node) {\n      rightNode.parent.left = rightNode;\n    } else {\n      rightNode.parent.right = rightNode;\n    }\n  }\n\n  node.parent    = rightNode;\n  rightNode.left = node;\n\n  node.balanceFactor += 1;\n  if (rightNode.balanceFactor < 0) {\n    node.balanceFactor -= rightNode.balanceFactor;\n  }\n\n  rightNode.balanceFactor += 1;\n  if (node.balanceFactor > 0) {\n    rightNode.balanceFactor += node.balanceFactor;\n  }\n  return rightNode;\n}\n\nfunction rotateRight (node) {\n  var leftNode = node.left;\n  node.left = leftNode.right;\n  if (node.left) node.left.parent = node;\n\n  leftNode.parent = node.parent;\n  if (leftNode.parent) {\n    if (leftNode.parent.left === node) {\n      leftNode.parent.left = leftNode;\n    } else {\n      leftNode.parent.right = leftNode;\n    }\n  }\n\n  node.parent    = leftNode;\n  leftNode.right = node;\n\n  node.balanceFactor -= 1;\n  if (leftNode.balanceFactor > 0) {\n    node.balanceFactor -= leftNode.balanceFactor;\n  }\n\n  leftNode.balanceFactor -= 1;\n  if (node.balanceFactor < 0) {\n    leftNode.balanceFactor += node.balanceFactor;\n  }\n\n  return leftNode;\n}\n\n// function leftBalance (node) {\n//   if (node.left.balanceFactor === -1) rotateLeft(node.left);\n//   return rotateRight(node);\n// }\n\n// function rightBalance (node) {\n//   if (node.right.balanceFactor === 1) rotateRight(node.right);\n//   return rotateLeft(node);\n// }\n\nexport default class AVLTree {\n  /**\n   * Callback for comparator\n   * @callback comparatorCallback\n   * @param {Key} a\n   * @param {Key} b\n   * @returns {number}\n   */\n\n  /**\n   * @class AVLTree\n   * @constructor\n   * @param  {comparatorCallback} [comparator]\n   * @param  {boolean}            [noDuplicates=false] Disallow duplicates\n   */\n  constructor (comparator, noDuplicates = false) {\n    this._comparator = comparator || DEFAULT_COMPARE;\n    this._root = null;\n    this._size = 0;\n    this._noDuplicates = !!noDuplicates;\n  }\n\n  /**\n   * Clear the tree\n   * @return {AVLTree}\n   */\n  destroy() {\n    return this.clear();\n  }\n\n  /**\n   * Clear the tree\n   * @return {AVLTree}\n   */\n  clear() {\n    this._root = null;\n    this._size = 0;\n    return this;\n  }\n\n  /**\n   * Number of nodes\n   * @return {number}\n   */\n  get size () {\n    return this._size;\n  }\n\n  /**\n   * Whether the tree contains a node with the given key\n   * @param  {Key} key\n   * @return {boolean} true/false\n   */\n  contains (key) {\n    if (this._root)  {\n      var node       = this._root;\n      var comparator = this._comparator;\n      while (node)  {\n        var cmp = comparator(key, node.key);\n        if      (cmp === 0) return true;\n        else if (cmp < 0)   node = node.left;\n        else                node = node.right;\n      }\n    }\n    return false;\n  }\n\n  /* eslint-disable class-methods-use-this */\n\n  /**\n   * Successor node\n   * @param  {Node} node\n   * @return {?Node}\n   */\n  next (node) {\n    var successor = node;\n    if (successor) {\n      if (successor.right) {\n        successor = successor.right;\n        while (successor.left) successor = successor.left;\n      } else {\n        successor = node.parent;\n        while (successor && successor.right === node) {\n          node = successor; successor = successor.parent;\n        }\n      }\n    }\n    return successor;\n  }\n\n  /**\n   * Predecessor node\n   * @param  {Node} node\n   * @return {?Node}\n   */\n  prev (node) {\n    var predecessor = node;\n    if (predecessor) {\n      if (predecessor.left) {\n        predecessor = predecessor.left;\n        while (predecessor.right) predecessor = predecessor.right;\n      } else {\n        predecessor = node.parent;\n        while (predecessor && predecessor.left === node) {\n          node = predecessor;\n          predecessor = predecessor.parent;\n        }\n      }\n    }\n    return predecessor;\n  }\n  /* eslint-enable class-methods-use-this */\n\n  /**\n   * Callback for forEach\n   * @callback forEachCallback\n   * @param {Node} node\n   * @param {number} index\n   */\n\n  /**\n   * @param  {forEachCallback} callback\n   * @return {AVLTree}\n   */\n  forEach(callback) {\n    var current = this._root;\n    var s = [], done = false, i = 0;\n\n    while (!done) {\n      // Reach the left most Node of the current Node\n      if (current) {\n        // Place pointer to a tree node on the stack\n        // before traversing the node's left subtree\n        s.push(current);\n        current = current.left;\n      } else {\n        // BackTrack from the empty subtree and visit the Node\n        // at the top of the stack; however, if the stack is\n        // empty you are done\n        if (s.length > 0) {\n          current = s.pop();\n          callback(current, i++);\n\n          // We have visited the node and its left\n          // subtree. Now, it's right subtree's turn\n          current = current.right;\n        } else done = true;\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Walk key range from `low` to `high`. Stops if `fn` returns a value.\n   * @param  {Key}      low\n   * @param  {Key}      high\n   * @param  {Function} fn\n   * @param  {*?}       ctx\n   * @return {SplayTree}\n   */\n  range(low, high, fn, ctx) {\n    const Q = [];\n    const compare = this._comparator;\n    let node = this._root, cmp;\n\n    while (Q.length !== 0 || node) {\n      if (node) {\n        Q.push(node);\n        node = node.left;\n      } else {\n        node = Q.pop();\n        cmp = compare(node.key, high);\n        if (cmp > 0) {\n          break;\n        } else if (compare(node.key, low) >= 0) {\n          if (fn.call(ctx, node)) return this; // stop if smth is returned\n        }\n        node = node.right;\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Returns all keys in order\n   * @return {Array<Key>}\n   */\n  keys () {\n    var current = this._root;\n    var s = [], r = [], done = false;\n\n    while (!done) {\n      if (current) {\n        s.push(current);\n        current = current.left;\n      } else {\n        if (s.length > 0) {\n          current = s.pop();\n          r.push(current.key);\n          current = current.right;\n        } else done = true;\n      }\n    }\n    return r;\n  }\n\n  /**\n   * Returns `data` fields of all nodes in order.\n   * @return {Array<Value>}\n   */\n  values () {\n    var current = this._root;\n    var s = [], r = [], done = false;\n\n    while (!done) {\n      if (current) {\n        s.push(current);\n        current = current.left;\n      } else {\n        if (s.length > 0) {\n          current = s.pop();\n          r.push(current.data);\n          current = current.right;\n        } else done = true;\n      }\n    }\n    return r;\n  }\n\n  /**\n   * Returns node at given index\n   * @param  {number} index\n   * @return {?Node}\n   */\n  at (index) {\n    // removed after a consideration, more misleading than useful\n    // index = index % this.size;\n    // if (index < 0) index = this.size - index;\n\n    var current = this._root;\n    var s = [], done = false, i = 0;\n\n    while (!done) {\n      if (current) {\n        s.push(current);\n        current = current.left;\n      } else {\n        if (s.length > 0) {\n          current = s.pop();\n          if (i === index) return current;\n          i++;\n          current = current.right;\n        } else done = true;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Returns node with the minimum key\n   * @return {?Node}\n   */\n  minNode () {\n    var node = this._root;\n    if (!node) return null;\n    while (node.left) node = node.left;\n    return node;\n  }\n\n  /**\n   * Returns node with the max key\n   * @return {?Node}\n   */\n  maxNode () {\n    var node = this._root;\n    if (!node) return null;\n    while (node.right) node = node.right;\n    return node;\n  }\n\n  /**\n   * Min key\n   * @return {?Key}\n   */\n  min () {\n    var node = this._root;\n    if (!node) return null;\n    while (node.left) node = node.left;\n    return node.key;\n  }\n\n  /**\n   * Max key\n   * @return {?Key}\n   */\n  max () {\n    var node = this._root;\n    if (!node) return null;\n    while (node.right) node = node.right;\n    return node.key;\n  }\n\n  /**\n   * @return {boolean} true/false\n   */\n  isEmpty() {\n    return !this._root;\n  }\n\n  /**\n   * Removes and returns the node with smallest key\n   * @return {?Node}\n   */\n  pop () {\n    var node = this._root, returnValue = null;\n    if (node) {\n      while (node.left) node = node.left;\n      returnValue = { key: node.key, data: node.data };\n      this.remove(node.key);\n    }\n    return returnValue;\n  }\n\n  /**\n   * Removes and returns the node with highest key\n   * @return {?Node}\n   */\n  popMax () {\n    var node = this._root, returnValue = null;\n    if (node) {\n      while (node.right) node = node.right;\n      returnValue = { key: node.key, data: node.data };\n      this.remove(node.key);\n    }\n    return returnValue;\n  }\n\n  /**\n   * Find node by key\n   * @param  {Key} key\n   * @return {?Node}\n   */\n  find (key) {\n    var root = this._root;\n    // if (root === null)    return null;\n    // if (key === root.key) return root;\n\n    var subtree = root, cmp;\n    var compare = this._comparator;\n    while (subtree) {\n      cmp = compare(key, subtree.key);\n      if      (cmp === 0) return subtree;\n      else if (cmp < 0)   subtree = subtree.left;\n      else                subtree = subtree.right;\n    }\n\n    return null;\n  }\n\n  /**\n   * Insert a node into the tree\n   * @param  {Key} key\n   * @param  {Value} [data]\n   * @return {?Node}\n   */\n  insert (key, data) {\n    if (!this._root) {\n      this._root = {\n        parent: null, left: null, right: null, balanceFactor: 0,\n        key, data\n      };\n      this._size++;\n      return this._root;\n    }\n\n    var compare = this._comparator;\n    var node    = this._root;\n    var parent  = null;\n    var cmp     = 0;\n\n    if (this._noDuplicates) {\n      while (node) {\n        cmp = compare(key, node.key);\n        parent = node;\n        if      (cmp === 0) return null;\n        else if (cmp < 0)   node = node.left;\n        else                node = node.right;\n      }\n    } else {\n      while (node) {\n        cmp = compare(key, node.key);\n        parent = node;\n        if      (cmp <= 0)  node = node.left; //return null;\n        else                node = node.right;\n      }\n    }\n\n    var newNode = {\n      left: null,\n      right: null,\n      balanceFactor: 0,\n      parent, key, data\n    };\n    var newRoot;\n    if (cmp <= 0) parent.left  = newNode;\n    else         parent.right = newNode;\n\n    while (parent) {\n      cmp = compare(parent.key, key);\n      if (cmp < 0) parent.balanceFactor -= 1;\n      else         parent.balanceFactor += 1;\n\n      if        (parent.balanceFactor === 0) break;\n      else if   (parent.balanceFactor < -1) {\n        // inlined\n        //var newRoot = rightBalance(parent);\n        if (parent.right.balanceFactor === 1) rotateRight(parent.right);\n        newRoot = rotateLeft(parent);\n\n        if (parent === this._root) this._root = newRoot;\n        break;\n      } else if (parent.balanceFactor > 1) {\n        // inlined\n        // var newRoot = leftBalance(parent);\n        if (parent.left.balanceFactor === -1) rotateLeft(parent.left);\n        newRoot = rotateRight(parent);\n\n        if (parent === this._root) this._root = newRoot;\n        break;\n      }\n      parent = parent.parent;\n    }\n\n    this._size++;\n    return newNode;\n  }\n\n  /**\n   * Removes the node from the tree. If not found, returns null.\n   * @param  {Key} key\n   * @return {?Node}\n   */\n  remove (key) {\n    if (!this._root) return null;\n\n    var node = this._root;\n    var compare = this._comparator;\n    var cmp = 0;\n\n    while (node) {\n      cmp = compare(key, node.key);\n      if      (cmp === 0) break;\n      else if (cmp < 0)   node = node.left;\n      else                node = node.right;\n    }\n    if (!node) return null;\n\n    var returnValue = node.key;\n    var max, min;\n\n    if (node.left) {\n      max = node.left;\n\n      while (max.left || max.right) {\n        while (max.right) max = max.right;\n\n        node.key = max.key;\n        node.data = max.data;\n        if (max.left) {\n          node = max;\n          max = max.left;\n        }\n      }\n\n      node.key  = max.key;\n      node.data = max.data;\n      node = max;\n    }\n\n    if (node.right) {\n      min = node.right;\n\n      while (min.left || min.right) {\n        while (min.left) min = min.left;\n\n        node.key  = min.key;\n        node.data = min.data;\n        if (min.right) {\n          node = min;\n          min = min.right;\n        }\n      }\n\n      node.key  = min.key;\n      node.data = min.data;\n      node = min;\n    }\n\n    var parent = node.parent;\n    var pp     = node;\n    var newRoot;\n\n    while (parent) {\n      if (parent.left === pp) parent.balanceFactor -= 1;\n      else                    parent.balanceFactor += 1;\n\n      if        (parent.balanceFactor < -1) {\n        // inlined\n        //var newRoot = rightBalance(parent);\n        if (parent.right.balanceFactor === 1) rotateRight(parent.right);\n        newRoot = rotateLeft(parent);\n\n        if (parent === this._root) this._root = newRoot;\n        parent = newRoot;\n      } else if (parent.balanceFactor > 1) {\n        // inlined\n        // var newRoot = leftBalance(parent);\n        if (parent.left.balanceFactor === -1) rotateLeft(parent.left);\n        newRoot = rotateRight(parent);\n\n        if (parent === this._root) this._root = newRoot;\n        parent = newRoot;\n      }\n\n      if (parent.balanceFactor === -1 || parent.balanceFactor === 1) break;\n\n      pp     = parent;\n      parent = parent.parent;\n    }\n\n    if (node.parent) {\n      if (node.parent.left === node) node.parent.left  = null;\n      else                           node.parent.right = null;\n    }\n\n    if (node === this._root) this._root = null;\n\n    this._size--;\n    return returnValue;\n  }\n\n  /**\n   * Bulk-load items\n   * @param  {Array<Key>}  keys\n   * @param  {Array<Value>}  [values]\n   * @return {AVLTree}\n   */\n  load(keys = [], values = [], presort) {\n    if (this._size !== 0) throw new Error('bulk-load: tree is not empty');\n    const size = keys.length;\n    if (presort) sort(keys, values, 0, size - 1, this._comparator);\n    this._root = loadRecursive(null, keys, values, 0, size);\n    markBalance(this._root);\n    this._size = size;\n    return this;\n  }\n\n  /**\n   * Returns true if the tree is balanced\n   * @return {boolean}\n   */\n  isBalanced() {\n    return isBalanced(this._root);\n  }\n\n  /**\n   * String representation of the tree - primitive horizontal print-out\n   * @param  {Function(Node):string} [printNode]\n   * @return {string}\n   */\n  toString (printNode) {\n    return print(this._root, printNode);\n  }\n}\n\nAVLTree.default = AVLTree;\n",
  "import { DEFAULT_MAX_TEXTURE_SIZE, DEFAULT_MIN_TEXTURE_SIZE } from \"./TextureSlotAllocator\";\n\nexport type TextureSize = 16 | 32 | 64 | 128 | 256 | 512 | 1024 | 2048 | 4096 | 8192 | 16384 | number;\nexport type TextureIndex = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31;\n\nexport interface Slot {\n  readonly size: [TextureSize, TextureSize];\n  readonly slotNumber: number;\n  readonly x: number, y: number;\n  readonly textureIndex: TextureIndex;\n}\n\nexport class TextureSlot implements Slot {\n  readonly size: [TextureSize, TextureSize];\n  readonly slotNumber: number;\n  readonly x: number;\n  readonly y: number;\n  readonly textureIndex: TextureIndex;\n  readonly parent?: TextureSlot;\n  sibbling?: TextureSlot;\n  textureSizeLimits: { min: TextureSize, max: TextureSize };\n\n  constructor(size: [TextureSize, TextureSize], slotNumber: number, parent?: TextureSlot, textureSizeLimits?: { min: TextureSize, max: TextureSize }) {\n    this.textureSizeLimits = parent?.textureSizeLimits ?? textureSizeLimits ?? { min: DEFAULT_MIN_TEXTURE_SIZE, max: DEFAULT_MAX_TEXTURE_SIZE }\n    this.size = size;\n    this.slotNumber = slotNumber;\n    this.parent = parent;\n    this.sibbling = undefined;\n    const { x, y, textureIndex } = this.calculatePosition(size, slotNumber);\n    this.x = x;\n    this.y = y;\n    this.textureIndex = textureIndex;\n  }\n\n  calculateTextureIndex(size: [TextureSize, TextureSize], slotNumber: number): TextureIndex {\n    const [w, h] = size;\n    const slotsPerTexture = (this.textureSizeLimits.max / w) * (this.textureSizeLimits.max / h);\n    return Math.floor(slotNumber / slotsPerTexture) as TextureIndex;\n  }\n\n  calculatePosition(size: [TextureSize, TextureSize], slotNumber: number) {\n    const [w, h] = size;\n    const slotsPerRow = this.textureSizeLimits.max / w;\n    const slotsPerColumn = this.textureSizeLimits.max / h;\n    const x = (slotNumber % slotsPerRow) * w;\n    const y = (Math.floor(slotNumber / slotsPerRow) % slotsPerColumn) * h;\n    return { x, y, textureIndex: this.calculateTextureIndex(size, slotNumber) };\n  }\n\n  getTag() {\n    return TextureSlot.getTag(this);\n  }\n\n  static getTag(slot: Slot) {\n    return `${slot.size[0]}x${slot.size[1]}-#${slot.slotNumber}`;\n  }\n\n  static positionToTextureSlot(x: number, y: number, size: [TextureSize, TextureSize], textureIndex: TextureIndex, parent: TextureSlot): TextureSlot {\n    const [w, h] = size;\n    const slotsPerRow = parent.textureSizeLimits.max / w;\n    const slotsPerTexture = (parent.textureSizeLimits.max / w) * (parent.textureSizeLimits.max / h);\n    const slotNumber = slotsPerTexture * textureIndex + (y / h) * slotsPerRow + (x / w);\n    return new TextureSlot(size, slotNumber, parent);\n  }\n\n  getPosition() {\n    return { x: this.x, y: this.y, size: this.size, textureIndex: this.textureIndex };\n  }\n\n  canSplitHorizontally() {\n    const [, h] = this.size;\n    return h > this.textureSizeLimits.min;\n  }\n\n  canSplitVertically() {\n    const [w,] = this.size;\n    return w > this.textureSizeLimits.min;\n  }\n\n  splitHorizontally(): [TextureSlot, TextureSlot] {\n    const { x, y, size, textureIndex } = this;\n    const [w, h] = size;\n    if (!this.canSplitHorizontally()) {\n      throw new Error(`Cannot split texture slot of size ${w} horizontally`);\n    }\n    const halfWidth = w / 2;\n    const left = TextureSlot.positionToTextureSlot(x, y, [halfWidth, h], textureIndex, this);\n    const right = TextureSlot.positionToTextureSlot(x + halfWidth, y, [halfWidth, h], textureIndex, this);\n    left.sibbling = right;\n    right.sibbling = left;\n    return [left, right];\n  }\n\n  splitVertically(): [TextureSlot, TextureSlot] {\n    const { x, y, size, textureIndex } = this;\n    const [w, h] = size;\n    if (!this.canSplitVertically()) {\n      throw new Error(`Cannot split texture slot of size ${h} vertically`);\n    }\n    const halfHeight = h / 2;\n    const top = TextureSlot.positionToTextureSlot(x, y, [w, halfHeight], textureIndex, this);\n    const bottom = TextureSlot.positionToTextureSlot(x, y + halfHeight, [w, halfHeight], textureIndex, this);\n    top.sibbling = bottom;\n    bottom.sibbling = top;\n    return [top, bottom];\n  }\n}\n",
  "import { TextureSize } from \"./TextureSlot\";\n\n//  This returns the smallest size that is a power of 2 and is larger than the given size\nexport function getMinTextureSlotSize(size: number, minSize: number): TextureSize {\n  return Math.max(minSize, Math.pow(2, Math.ceil(Math.log(size) / Math.log(2))));\n}\n\n//  This rearranges the 'count' sprites into various sprite sheets\nexport function getFlexSizes(w: number, h: number, count: number, textureSizeLimits: { min: number, max: number }) {\n  if (count < 1) {\n    throw new Error(\"Invalid count\");\n  }\n  const wFixed = getMinTextureSlotSize(w, textureSizeLimits.min), hFixed = getMinTextureSlotSize(h, textureSizeLimits.min);\n  const flexSizes: Map<TextureSize, TextureSize> = new Map();\n  let wSize = textureSizeLimits.min;\n\n  for (let i = 1; i <= count; i++) {\n    wSize = getMinTextureSlotSize(wFixed * i, textureSizeLimits.min);\n    const hSize = getMinTextureSlotSize(hFixed * Math.ceil(count / i), textureSizeLimits.min);\n    flexSizes.set(wSize, hSize);\n  }\n  for (let size = wSize; size <= textureSizeLimits.max; size *= 2) {\n    if (!flexSizes.has(size)) {\n      flexSizes.set(size, hFixed);\n    }\n  }\n  return flexSizes;\n}\n",
  "// To recognize dom types (see https://bun.sh/docs/typescript#dom-types):\n/// <reference lib=\"dom\" />\n/// <reference lib=\"dom.iterable\" />\n\nimport AVLTree from 'avl';\nimport { Slot, TextureSize, TextureSlot } from './TextureSlot';\nimport { getFlexSizes } from './TextureUtils';\n\nconst DEBUG = false;\nexport const DEFAULT_MIN_TEXTURE_SIZE = 16;\nexport const DEFAULT_MAX_TEXTURE_SIZE = 4096;\nexport const DEFAULT_NUM_TEXTURE_SHEETS = 16;\n\nexport interface Props {\n  numTextureSheets?: number;\n  minTextureSize?: TextureSize;\n  maxTextureSize?: TextureSize;\n}\n\nexport class TextureSlotAllocator {\n  //  AVL tree of texture slots, sorted by size\n  textureSlots = new AVLTree<TextureSlot, TextureSlot>((slot1, slot2) => {\n    const sizeDiff = slot1.size[0] * slot1.size[1] - slot2.size[0] * slot2.size[1];\n    if (sizeDiff !== 0) {\n      return sizeDiff;\n    }\n    return slot1.slotNumber - slot2.slotNumber;\n  }, false);\n\n  private allocatedTextures: Record<string, TextureSlot> = {};\n  minTextureSize: TextureSize;\n  maxTextureSize: TextureSize;\n  numTextureSheets: number;\n\n  constructor({ numTextureSheets, minTextureSize, maxTextureSize }: Props = {}, gl?: WebGL2RenderingContext) {\n    this.numTextureSheets = numTextureSheets ?? DEFAULT_NUM_TEXTURE_SHEETS;\n    this.minTextureSize = minTextureSize ?? DEFAULT_MIN_TEXTURE_SIZE;\n    this.maxTextureSize = maxTextureSize ?? DEFAULT_MAX_TEXTURE_SIZE;\n\n    if (gl) {\n      this.numTextureSheets = Math.min(this.numTextureSheets, gl.getParameter(WebGL2RenderingContext.MAX_TEXTURE_IMAGE_UNITS));\n      this.maxTextureSize = Math.min(this.maxTextureSize, gl.getParameter(WebGL2RenderingContext.MAX_TEXTURE_SIZE));\n      this.minTextureSize = Math.min(this.minTextureSize, this.maxTextureSize);\n    }\n\n    for (let i = 0; i < this.numTextureSheets; i++) {\n      this.textureSlots.insert(new TextureSlot([this.maxTextureSize, this.maxTextureSize], i, undefined, {\n        min: this.minTextureSize,\n        max: this.maxTextureSize,\n      }));\n    }\n  }\n\n  allocate(w: number, h: number, count: number = 1): Slot {\n    const { size, slotNumber, x, y, textureIndex } = this.allocateHelper(w, h, count);\n    return { size, slotNumber, x, y, textureIndex };\n  }\n\n  deallocate(slot: Slot): void {\n    if (!this.isSlotUsed(slot)) {\n      throw new Error('Slot is not allocated');\n    }\n    const textureSlot = this.allocatedTextures[TextureSlot.getTag(slot)];\n    this.deallocateHelper(textureSlot);\n  }\n\n  private allocateHelper(w: number, h: number, count: number = 1): TextureSlot {\n    const flexSizes = getFlexSizes(w, h, count, { min: this.minTextureSize, max: this.maxTextureSize });\n\n    const slot = this.findSlot(flexSizes);\n    if (!slot) {\n      throw new Error(`Could not find a slot for texture to fit ${count} sprites of size ${w}x${h}`);\n    }\n    this.textureSlots.remove(slot);\n\n    //  Fit the best size into the slot\n    const [bestWidth, bestHeight] = this.bestFit(flexSizes, slot);\n    return this.fitSlot(slot, bestWidth, bestHeight);\n  }\n\n  private findSlot(flexSizes: Map<TextureSize, TextureSize>): TextureSlot | null {\n    for (let i = 0; i < this.textureSlots.size; i++) {\n      const slot = this.textureSlots.at(i);\n      const textureSlot = slot!.key!;\n      const [w, h] = textureSlot.size;\n      if (flexSizes.get(w)! <= h) {\n        return textureSlot;\n      }\n    }\n    return null;\n  }\n\n  private calculateRatio(w: number, h: number): number {\n    return Math.max(w / h, h / w);\n  }\n\n  private bestFit(flexSizes: Map<TextureSize, TextureSize>, slot: TextureSlot): [TextureSize, TextureSize] {\n    const [slotWidth, slotHeight] = slot.size;\n    let bestWidth = slot.textureSizeLimits.max;\n    flexSizes.forEach((hSize, wSize) => {\n      if (wSize <= slotWidth && hSize <= slotHeight) {\n        const product = wSize * hSize;\n        const bestProduct = flexSizes.get(bestWidth)! * bestWidth;\n        if (product < bestProduct) {\n          bestWidth = wSize;\n        } else if (product === bestProduct) {\n          const ratio = this.calculateRatio(wSize, hSize);\n          if (ratio < this.calculateRatio(bestWidth, flexSizes.get(bestWidth)!)) {\n            bestWidth = wSize;\n          }\n        }\n      }\n    });\n    return [bestWidth, flexSizes.get(bestWidth)!];\n  }\n\n  private isSlotUsed(slot: Slot): boolean {\n    return !!this.allocatedTextures[TextureSlot.getTag(slot)];\n  }\n\n  private deallocateHelper(slot: TextureSlot): void {\n    //  check if we can merge with the sibbling\n    if (slot.parent && slot.sibbling && !this.isSlotUsed(slot.sibbling)) {\n      const sibbling = slot.sibbling;\n      this.textureSlots.remove(sibbling);\n      if (DEBUG && this.textureSlots.find(slot)) {\n        throw new Error('Slot is not expected to be in the tree');\n      }\n      const parent = slot.parent;\n      this.deallocateHelper(parent);\n      return;\n    }\n    this.textureSlots.insert(slot);\n    delete this.allocatedTextures[slot.getTag()];\n  }\n\n  private trySplitHorizontally(slot: TextureSlot, w: number, h: number): TextureSlot | null {\n    if (slot.canSplitHorizontally()) {\n      const [leftColumn, rightColumn] = slot.splitHorizontally();\n      // First try to split vertically\n      if (leftColumn.size[0] >= w) {\n        this.textureSlots.insert(rightColumn);\n        return this.fitSlot(leftColumn, w, h);\n      }\n    }\n    return null;\n  }\n\n  private trySplitVertically(slot: TextureSlot, w: number, h: number): TextureSlot | null {\n    if (slot.canSplitVertically()) {\n      const [topRow, bottomRow] = slot.splitVertically();\n      // Then try to split vertically\n      if (topRow.size[1] >= h) {\n        this.textureSlots.insert(bottomRow);\n        return this.fitSlot(topRow, w, h);\n      }\n    }\n    return null;\n  }\n\n  private fitSlot(slot: TextureSlot, w: number, h: number): TextureSlot {\n    this.allocatedTextures[slot.getTag()] = slot;\n    if (slot.size[0] > slot.size[1]) {\n      const splitAttempt = this.trySplitHorizontally(slot, w, h)\n        ?? this.trySplitVertically(slot, w, h);\n      if (splitAttempt) {\n        return splitAttempt;\n      }\n    } else {\n      const splitAttempt = this.trySplitVertically(slot, w, h)\n        ?? this.trySplitHorizontally(slot, w, h);\n      if (splitAttempt) {\n        return splitAttempt;\n      }\n    }\n    //  Return that slot if we can't split it further\n    return slot;\n  }\n\n  listSlots() {\n    this.textureSlots.forEach((node) => {\n      console.log(node.key?.getTag());\n    });\n  }\n}\n",
  "import { Slot, TextureSize, TextureSlot } from \"texture/TextureSlot\";\nimport { Props, TextureSlotAllocator } from \"texture/TextureSlotAllocator\";\n\n/**\n * ImagePacker\n * \n * This class packs images using TextureSlotAllocator into several spritesheets.\n * For use in WebGL as textures.\n */\ntype ImageSource = CanvasImageSource | string;\ntype ImageInfo = {\n  id: string;\n  image: ImageSource;\n  rows?: number;\n  cols?: number;\n};\n\nexport class ImagePacker {\n  constructor(public readonly images: ImageInfo[] = []) {\n  }\n\n  addImage(id: string, image: CanvasImageSource, cols: number = 1, rows: number = 1) {\n    this.images.push({ id, image, cols, rows });\n  }\n\n  clear() {\n    this.images.length = 0;\n  }\n\n  async getImage(src: string) {\n    const response = await fetch(src);\n    const blob = await response.blob();\n    return await createImageBitmap(blob);\n  }\n\n  async loadImage(image: ImageSource): Promise<CanvasImageSource> {\n    if (typeof (image) !== 'string') {\n      return image;\n    }\n    return await this.getImage(image);\n  }\n\n  async pack(props: Props = {}): Promise<{\n    images: ImageBitmap[],\n    slots: {\n      id: string;\n      slot: Slot,\n    }[],\n    compact: Record<string, string>,\n    textureSize: TextureSize,\n  }> {\n    const canvases: OffscreenCanvas[] = [];\n\n    const imageInfos: { id: string, image: CanvasImageSource, cols: number, rows: number, spriteWidth: number, spriteHeight: number, count: number }[] = await Promise.all(this.images.map(async image => {\n      const img: any = image.image;\n      if (typeof (img) === \"string\") {\n        throw new Error(\"ImagePacker: image is not loaded\");\n      }\n      const width: number = img.naturalWidth ?? img.displayWidth ?? img.width?.baseValue?.value ?? img.width;\n      const height: number = img.naturalHeight ?? img.displayHeight ?? img.height?.baseValue?.value ?? img.height;\n      const cols = image.cols || 1;\n      const rows = image.rows || 1;\n\n      return {\n        id: image.id,\n        image: await this.loadImage(image.image),\n        cols, rows,\n        spriteWidth: width / cols,\n        spriteHeight: height / rows,\n        count: rows * cols,\n      };\n    }));\n\n    const allocator = new TextureSlotAllocator(props);\n\n    imageInfos.sort((info1, info2) => {\n      const size1 = info1.cols * info1.spriteWidth + info1.rows * info1.spriteHeight;\n      const size2 = info2.cols * info2.spriteWidth + info2.rows * info2.spriteHeight;\n      return size2 - size1;\n    });\n\n    const slots: { id: string; slot: Slot }[] = [];\n    imageInfos.forEach(imageInfo => {\n      const { id, image, spriteWidth, spriteHeight, count } = imageInfo;\n      const slot = allocator.allocate(spriteWidth, spriteHeight, count);\n      if (slot.textureIndex >= canvases.length) {\n        const canvas = new OffscreenCanvas(allocator.maxTextureSize, allocator.maxTextureSize);\n        canvases.push(canvas);\n      }\n      const canvas = canvases[slot.textureIndex];\n      const ctx = canvas.getContext('2d');\n      if (!ctx) {\n        throw new Error(\"Failed to get 2d context\");\n      }\n      ctx.imageSmoothingEnabled = true;\n      const [slotWidth, slotHeight] = slot.size;\n      const slotCols = Math.floor(slotWidth / spriteWidth);\n      const slotRows = Math.floor(slotHeight / spriteHeight);\n\n      for (let i = 0; i < count; i++) {\n        const x = slot.x + (i % slotCols) * spriteWidth;\n        const y = slot.y + Math.floor(i / slotRows) * spriteHeight;\n        ctx.drawImage(image, 0, 0, spriteWidth, spriteHeight, x, y, spriteWidth, spriteHeight);\n      }\n      slots.push({ id, slot });\n    });\n    slots.sort((a, b) => a.id.localeCompare(b.id));\n    const compact: [string, string][] = slots.map(({ id, slot }) => ([id, TextureSlot.getTag(slot)]));\n\n    const images = await Promise.all(canvases.map(canvas => createImageBitmap(canvas)));\n    return {\n      images, slots, compact: Object.fromEntries(compact), textureSize: allocator.maxTextureSize,\n    };\n  }\n}\n"
  ],
  "mappings": "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",
  "debugId": "4AACA72F6D1C93CC64756e2164756e21",
  "names": []
}